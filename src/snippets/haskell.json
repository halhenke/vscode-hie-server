{
  "$schema": "vscode://schemas/snippets",
	"Language Extension": {
		"prefix": "lang",
		"body": [
			"{-# LANGUAGE ${1|AllowAmbiguousTypes,ApplicativeDo,Arrows,AutoDeriveTypeable,BangPatterns,CApiFFI,ConstrainedClassMethods,ConstraintKinds,CPP,DataKinds,DatatypeContexts,DefaultSignatures,DeriveAnyClass,DeriveDataTypeable,DeriveFoldable,DeriveFunctor,DeriveGeneric,DeriveLift,DeriveTraversable,DisambiguateRecordFields,DoRec,DuplicateRecordFields,EmptyCase,EmptyDataDecls,ExistentialQuantification,ExplicitForAll,ExplicitNamespaces,ExtendedDefaultRules,FlexibleContexts,FlexibleInstances,ForeignFunctionInterface,FunctionalDependencies,GADTs,GADTSyntax,GeneralizedNewtypeDeriving,GHCForeignImportPrim,ImplicitParams,ImpredicativeTypes,IncoherentInstances,InstanceSigs,InterruptibleFFI,KindSignatures,LambdaCase,LiberalTypeSynonyms,MagicHash,MonadComprehensions,MonoLocalBinds,MonoPatBinds,MultiParamTypeClasses,MultiWayIf,NamedFieldPuns,NegativeLiterals,NoImplicitPrelude,NoMonomorphismRestriction,NPlusKPatterns,NullaryTypeClasses,NumDecimals,OverlappingInstances,OverloadedLabels,OverloadedLists,OverloadedRecordFields,OverloadedStrings,PackageImports,ParallelArrays,ParallelListComp,PartialTypeSignatures,PatternGuards,PatternSynonyms,PolyKinds,PolymorphicComponents,PostfixOperators,QuasiQuotes,Rank2Types,RankNTypes,RebindableSyntax,RecordWildCards,RecursiveDo,RelaxedPolyRec,RoleAnnotations,Safe,SafeImports,ScopedTypeVariables,StandaloneDeriving,StaticPointers,Strict,StrictData,TemplateHaskell,TraditionalRecordSyntax,TransformListComp,Trustworthy,TupleSections,Typeable,TypeApplications,TypeFamilies,TypeHoles,TypeInType,TypeOperators,TypeSynonymInstances,UnboxedTuples,UndecidableInstances,UnicodeSyntax,UnliftedFFITypes,Unsafe,ViewPatterns|} #-}"
		],
		"description": "Insert a Language Extension Pragma"
	},
	"import qualified": {
		"prefix": "import",
		"description": "import qualified module as",
		"body": "import qualified $1 as $2"
	},
	"import as": {
		"prefix": "import",
		"description": "import module as",
		"body": "import $1 as $2"
	},
	"import": {
		"prefix": "import",
		"description": "import module",
		"body": "import $1"
		// "body": "import ${1|qualified,nope|} $2 as $3"
	},
	"default": {
		"prefix": "default",
		"body": "default ($1)",
		"description": "Set default data types for literals"
  },
  "let statement": {
    "prefix": "let",
    "body": [
      "let \t$1",
      "\t$2",
      "in $3"
    ]
  },
	"case expression": {
		"prefix": "case",
		"body": [
			"case ${1:a} of",
			"\t${Left} -> ${this}",
			"\t${Right} -> ${that}"
			// "| $3"
		],
		"description": "Insert a case expression"
	},
	"if/else expression": {
		"prefix": "if",
		"body": [
			"case ${1:a} of",
			"\tLeft -> this",
			"\tRight -> that"
			// "| $3"
		],
		"description": "if/else expression"
	},
	"deriving - standalone": {
		"prefix": "deriving",
		"body": "deriving instance ${1|Show,Eq,Ord,Other|} ${2:m} => $1 $2",
		"description": "Insert a standalone deriving declaration"
	},
	"comment header": {
		"prefix": "header",
		"description": "A Heading Block",
		"body": [
			"-- *************************************************",
			"-- EXPERIMENTING WITH REFLECTION",
			"-- *************************************************"
		]
	},
	"do": {
		"prefix": "do",
		"body": [
				"do",
				"\t$0",
				"\t${1:return value}"
		],
		"description": "Do notation snippet."
	},
	"instance": {
		"prefix": "instance",
		"body": [
			"instance ${1|Show, Eq, Ord, Other|} ${2: m} => $1 $2 where",
			"\t${3:function} = ${4:id}",
			"\t$0"
		],
		"description": "Implement a typeclass instance"
	},
	"data - Simple ADT": {
		"prefix": "data",
		"body": [
			"data ${1:Foo} = $1 ${2|Type,''|}",
			"\t| $0"
		],
		"description": "Insert a new data type definition"
	},
	"data - Polymorphic ADT": {
		"prefix": "data",
		"body": [
			"data ${1:Foo} ${2:a} = $1 $2",
			"\t| $0"
		],
		"description": "Insert a new higher kinded data type definition"
	},
	"data - GADT syntax": {
		"prefix": "data",
		"body": [
			"data ${1:Thing} where",
			"\t${2:Thing} :: ${3:Thing}"
		],
		"description": "Insert a new GADT data type definition"
	},
	"Function": {
		"prefix": "fun",
		"body": [
				"${1:name} :: ${type1:Int} -> ${type2:Int}",
				"$1 ${val} = ${expr1}",
				"$1 ${val2:_} = ${expr2}"
		],
		"description": "Function declaration snippet."
	},
	"let": {
		"prefix": "let",
		"body": [
				"let",
				"\t${1:name} = ${2:value}",
				"in",
				"\t${3:undefined} "
		],
		"description": "Let binding snippet."
	},
	"where": {
			"prefix": "where",
			"body": [
					"where ${name} = ${value}"
			],
			"description": "Where binding snippet."
	},
	"where - statement": {
			"prefix": "where",
			"body": [
					"${1:a} ${2:b} where",
					"\t$1 = $3"
			],
			"description": "An expression with a where clause."
	},
	"main declaration": {
		"prefix": "main",
		"description": "Main Function declaration",
		"body": [
			"main :: IO ()",
			"main = ${0:putStrLn \"Hello World\"}"
		]
	},
	"module haddock declaration": {
		"prefix": "had",
		"description": "A description of the module and other fields that would be displayed at the top of any generated haddock documentation",
		"body": [
			"{-|",
				// "Module      : $TM_DIRECTORY/$TM_FILENAME_BASE",
				"Module      : $TM_FILENAME_BASE",
				"Description : ${2:A brief description}",
				"Copyright   : (c) Some Guy, 2018",
				"License     : MIT",
				"Maintainer  : ${3:sample@email.com}",
				"Stability   : ${4:experimental}",
				"Portability : POSIX",
				"\n",
				"${5:Here is a longer description of this module}",
				"-}"
		]
	},
	"module declaration - (basic)": {
		"prefix": "mod",
		"description": "Module declaration",
		"body": [
			"module ${1:$TM_DIRECTORY.$TM_FILENAME_BASE} () where",
			"$0"
		]
	},
	"module declaration": {
		"prefix": "mod",
		"description": "Module declaration",
		"body": [
			"module ${1:$TM_DIRECTORY.$TM_FILENAME_BASE} (",
			"\t${export:$1}",
			") where",
			"$0"
		]
	},
	"stack script": {
		"prefix": "script",
		"description": "Setup the skeleton of a standard stack script",
		"body": [
			"#!/usr/bin/env stack",
			"{-  stack",
				"\t--install-ghc",
				"\t--resolver ${$1}",
				"\t--stack-yaml $TM_FILENAME_BASE",
				"\trunghc",
				"\t--package $TM_FILE_NAME_BASE",
			"-}\n\n",
			"module $TM_FILE_NAME_BASE where\n",
			"import Protolude\n",
			"main :: IO ()",
			"main = print \"Do Something...\""
		]
	}
}
